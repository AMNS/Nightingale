I. Nightingale Coding Conventions
	A. Nightingale Technical Note #2. Don Byrd, AMNS, revised 26 December 1996
II. In General
	A. Naturally, the “purest” examples of my coding conventions are in the files written entirely (or almost entirely) by me, especially DebugXXX.c, MIDIXXX.c, and RTRhythmDur.c. The least pure by far are in Doug McKenna’s code; actually these are pure examples of coding conventions alright, but they’re his, not mine (or AMNS’).
	B. I *highly* recommend Steve Maguire’s Writing Solid Code (Microsoft Press, 1993). It not only contains a tremendous amount of excellent advice on every aspect of “writing solid code”, including coding style, but it’s exceptionally readable and to-the-point: he doesn’t waste your time. One observation he makes that justifies a lot of the following guidelines is that it's very likely that at some point someone who knows less about the program than you do will need to understand your code; it's also quite possible that they won't be an outstanding programmer. As Maguire puts it, "Write code for the 'average' programmer."
III. Naming and spelling conventions
	A. Names in General
		1. In order to minimize typing errors, statements that need line breaks, etc., use the shortest name that’s clear. Of course, it's not always easy to decide  what's clear; when in doubt, it's probably better to err on the side of clarity (=length). Here are are some examples:
			a. Use InitXXX, not InitializeXXX: it's very obvious what "Init" means, and it saves a lot of characters (six, to be exact). Also, use “Min” and “Max”, not “Minimum” and “Maximum”: the case is slightly weaker because they don’t save as many characters, but it’s still hard to imagine anyone failing to know what they stand for.
On the other hand:
			Use "offset", not "ofst" or "off": "ofst" and "off" are unclear, and they save only two or three characters anyway.
			Use "count" instead of "cnt".
 		 Use "sequence" instead of "seq". But this could go the other way: "seq" saves five characters, and it could be clear, depending on context.
	B. CONSTANT_NAMES
		1. Constants should be in all capitals, e.g., MAXBLOCKS.  (This is still standard on Windows, though not the Mac.) Feel free to use embedded underlines for clarity.  For resources, follow the name with the resource type, e.g., MAXNOTES_ALRT; if the resource type uses characters that aren't legal in names, come as close as you can, e.g., end with _STRS for type “STR#”. Otherwise, wherever appropriate, precede the name with a standard class abbreviation, for example VM_ and EM_ for View Menu and Edit Menu constants.
			a. NAME_DLOG signifies a dialog ID
			b. NAME_ALRT signifies an alert ID
			c. XM_NAME signifies an item in a menu that starts with the letter X
			d. I_NAME signifies a DITL item ID
	C. variableNames
		1. Follow the Mac standard that all variable names begin with a lowercase letter.  If a name is made up of several words (like ‘note’ and ‘count’), capitalize the first letter of each word other than the first (as in ‘noteCount’ or ‘doneFlag’).
		2. Avoid underlines: the capitalization convention above achieves the same thing in fewer characters.
		3. We use partial “Hungarian notation”: if something is a pointer, the name should indicate it by starting with the letter ‘p’  (i.e., pNode). If it’s a link, it should end with ‘L’ (and should NOT start with ‘p’, except for the conventional ‘pL’!). Do not call a Point ‘p’, call it ‘pt’!
	D. FunctionNames
		1. Follow the Mac standard of starting each word of the name (including the first) with a capital letter. (Dave Winzler says historically, this is partially due to Apple’s early infatuation with Pascal, and partially due to the Smalltalk background of some people on the Lisa and Mac teams.)
		2. Names built from noun and verb words should be of the form VerbNoun (as in FixNodes, and PlayNotes rather than NodeFix or NotePlay).  This emphasizes the verb, implying that the function DOES something as opposed to being something.
		3. Avoid underlines in function names: the capitalization convention above achieves the same thing in fewer characters.
		4. Historical note: For the sake of earlier versions of MacsBug, we used to try to make function names unique in the first eight characters, but with recent versions this no longer matters.
		5. Predicates should have names that suggest they’re predicates, e.g., IsAfter or ShouldDrawBarline. The names should also suggest in which case the predicate returns TRUE, e.g., GoodValue instead of CheckValue—or even better, in view of the previous rule, IsGoodValue.
		6. Functions that count something should be named that way: CountBeamable is less ambiguous than BeamableNumber. Besides, “CountXXX” is the convention the Mac toolbox routines follow. Similarly, functions that deliver an indexed value should have standardized names. In Mac toolbox routines, this would be (for a CountFoo function) GetIndFoo. However, this is confusing to read: a better solution is GetNthFoo and GetNthFooQuick. The former does bounds checking on its index and other arguments; the latter doesn't, under the assumption it's being called from within a loop whose bounds have previously been determined by a call to CountFoo.
	E. File Names
		1. Files should be named bearing in mind a possible port to (ugh) Windows 3.1: if names are longer than eight characters, they should at least be unique in the first eight characters. But this is getting less important as Windows 3.1 recedes into the past.
IV. Use of whitespace
	A. It should be easy to see sections of a file, especially where functions begin, at a glance. Doug’s solution—indent absolutely everything but the initial comments and function header—wastes the left end of the screen (especially with tabs 4 spaces apart; I prefer 3, as mentioned below). My solution:
		1. Two blank lines between function definitions and separating major sections of files, e.g., between prototypes and the first function.
		2. Put something in front of every function that clearly separates it from the one above, e.g., “/* --------------------- FuncName -- */”. Exception: short and closely-related functions.
	B. Within functions, one blank line between declarations and executable code.
	C. One blank on each side of assignment operators (  =   -=    +=   and so on).
	D. No blanks around other relational and equality operators (==   >=   etc.) except where really needed for readability, e.g., because one side or the other is exceptionally complicated.
V. Tabs, fonts, indenting, etc.
	A. Set tabs 3 columns apart, not the usual 4! This saves screen width with no loss of readability at all.
	B. “{” does NOT go on a separate line.
	C. “}” always goes on a separate line. Indent it the same as the statement whose range it terminates, i.e., one tab to the left of lines within it.
	D. Statements within a block go on separate lines unless they’re very short and closely related.
	E. Use a small but readable monospaced font, preferably one in which, e.g., digit 1 and lower-case-ell are different: on the Mac, Courier 10 or Monaco 9 or something similar. Doug McKenna recommends the free Avignon 9 programmer's font.
	F. Lines should very rarely extend off the end of a window that’s full size on a standard 14-in. (640-pixel wide) monitor. Cases where such long lines are acceptable are things like very long string constants and comments at the right of a line of code—but in the latter case, SOME of the comment must be visible normally, or a reader may not realize there’s a comment there at all. As a general rule, keep lines down to 88 characters: that fits comfortably on a 640-pixel-wide screen in standard fonts.
	G. Always indents comments the same as the code they apply to.
	H. Never indent preprocessor directives except where complex nestings would otherwise make it very difficult to follow them.
VI. Functions and Prototypes
	A. Always run with Required Prototypes ON. In fact, Maguire makes a convincing case for setting all compiler checking to the highest possible level, and keeping compiles completely free of warnings if at all possible.
	B. Functions used only within a file should always be declared “static”, with prototypes either at the beginning of the file or at the beginning of the section of the file they pertain to.
	C. Functions in file “Barf.c” that must be callable from other files should have their prototypes in file “Barf.h” unless there are only a few such in Barf.c; in that case put them in NightingaleTemplates.h.
VII. Comments
	A. Comments describing conceptually what difficult blocks of code do, as opposed to comments describing on a low level what individual lines of code do, are extremely important. Take as much space as you need for such comments. If you feel they interrupt the flow of the code too much, put them at the top of the function and refer to them with a short comment where they apply. And don't forget that entire functions very often qualify as "difficult blocks of code"!
	B. Comments trailing code on the same line should be tabbed well to the right of the code, but of course try to keep a fair amount of the comment in the window.
	C. Comments pointing out things that will need attention later should begin with something distinctive. I used to begin them with “??”; these days, this could conflict with the ANSI/ISO C trigraph syntax, but in practice, that’d hardly ever be a problem. Another idea is to use C++ syntax (start each line with “//”): then you can be sure to find these comments by turning off C++ compatability! Finally, comments of this type that REALLY shouldn’t be forgotten should be in all caps.
	D. Comments in a function should not assume that they KNOW how the function is used, but they can certainly say how the function SHOULD be used. For example, at the top of the function, don’t say “Coordinates have already been updated”, say “We assume coordinates have already been updated”. This is particularly important for publically-visible functions.
	E. Comment out code you want to leave in the source for some reason by surrounding it with lines “#ifdef NOMORE” or “#ifdef NOTYET” or some such and “#endif”. This is much better than using genuine comment delimiters because “#if”s nest properly; comments don’t. And these #ifdefs are better than “#if 0” because they say WHY the code is commented out; use “#if 0” only if you’re certain the commenting out is VERY temporary.
VIII. Portability
	A. Unless there’s a very good reason not to, to enhance portability, write in ANSI/ISO standard C. Take full advantage of what it offers, but know and be careful about what it doesn’t guarantee. Of course, entire books have been written about this; here are a few brief thoughts, plus some references.
		1. Comments: I’ve seen several instances of people using C++-style comments (everything on a line after “//”) in Nightingale. I know this usage is likely to become standard C, but for now, please don’t, except perhaps for special comments you want to be able to find later (see the section on comments). 
		2. Library Functions: The  ANSI/ISO C library functions are extensive and powerful; use them whenever possible. But one thing to be careful of: according to  ANSI/ISO, the formatted input functions (the scanf family) and the string-to-number conversion functions (atof, atoi, and atol) have “undefined behavior” in some cases, for example, if the string doesn’t represent a legal number. In  ANSI/ISO-speak, “undefined behavior” means “can do anything including crash”! This is not acceptable in Nightingale or *any* commercial application. The only solution is to avoid using these functions. Instead of atof, atoi, and atol, use strtod, strtol, and strtol, respectively.
		3. As far as I know, you can't buy the standard itself for less than $300, but it's reprinted in Schildt's The Annotated ANSI C Standard (Osborne). Schildt’s annotations are extensive but useless because they’re addressed to C beginners. On the other hand, the standards committee also put out a "rationale" document explaining their decisions: it’s excellent, and currently available free on the World-Wide Web. Harbison and Steele’s C: A Reference Manual (Prentice Hall) doesn’t reprint the standard, but it contains detailed systematic comments on it, incomparably superior to Schildt’s. Harbison and Steele’s fourth edition also discusses “ISO C Amendment 1” and compatability with C++.
	B. As much as possible, avoid characters outside of ASCII, i.e., 0x80 and above. Windows character sets are completely incompatible with Mac ones, except for the ASCII subset. Specifically, in English-speaking locales and Western Europe, Windows uses Windows Latin 1, a.k.a. “ANSI”: that character set is totally different from Macintosh Roman. (However, it’s quite similar to—essentially, a superset of—the ISO 8859-1 character set that UNIX uses and that Unicode includes.) Avoid non-ASCII characters in comments as well as in code: in comments, of course, they won’t hurt the program’s behavior, but they may hurt the behavior of Windows programmers!
IX. Miscellany
	A. Write what you mean as precisely and as readably as possible.  For example, don’t write “0” when you mean “NULL” or “0L”.  Do NOT write a loop that’s exited only by break or jumping out of it as “for ( ; ; )”—there are good reasons for having such a loop, but “while (TRUE)” is much, much easier to understand.
		1. An important special case of writing readable code: “Magic numbers” are a no-no!  In most cases, a perfectly good way to avoid one is to give it a descriptive name and put it in a #define, with a comment. If the #define "should" go in a header file and you don't want to bother right now, it's much better to put the #define in the source file than to use the magic number: once the #define exists, it can easily be moved to the appropriate place later without someone having to figure out what the code does.
		2. For macros that want to consist of full or multiple C statements, the most robust syntax is along the lines of

    #define FOO(a,b)  do { something(a); something(b) } while(FALSE)

so you don't have to worry about semi-colons and if...else statements ending up wierd.

	B. Instead of writing a series of #defines for related things whose values must be distinct integers but otherwise don't matter, you should probably use enum instead. (But be careful with enums: if you #define a symbol to one value and enum it to another, your development system may not tell you (at least, THINK C didn’t a couple of years ago), and the result may be a hard-to-diagnose bug.)
	C. Re datatypes, use type Byte (=unsigned char) for binary data--e.g., buffers--only. Don’t declare variables that contain character data as Byte, since the definition of a character is likely to change someday to wchar_t or to “unsigned short”, in order to support Unicode.
	D. Re datatypes, don’t overuse casts. A cast, of course, tells the compiler “don’t worry about the type of this, I know what I’m doing”—but you might be wrong.
	E. Ranges of nodes in the main data structure or any list should be described with a “from” link that’s INSIDE the range and a “to” link that’s  OUTSIDE the range, so the range can be handled with something like “for (pL = from; pL!=to; pL = RightLINK(pL))”.
	F. Resist the temptation to assign a variable in the test part of an “if”. I suppose it’s wonderfully idiomatic, but after 10 years of writing C, I still find this style is almost always harder to read than assigning it in a separate statement, then testing it.
	G. Don’t worry about over-parenthesizing complex expressions. If you have to look up the precedence rules to see whether parentheses are really necessary, just put them in so the next person to look at the code doesn’t have to look them up--or, worse, fail to look them up and misunderstand the code as a result. Again see Maguire.
	H. Don’t write “if (Boolean expression==FALSE) ...” and “if (Boolean expression==TRUE) ...”, just write “if (!Boolean expression) ...” and “if (Boolean expression) ...” Clarity aside, if the Boolean expression has a value other than 0 or 1, it will fail to equal either FALSE or TRUE, and this is particularly insidious if the expression is just a function call. Again see Maguire.
	I. Arrange functions in modules by level consistently: in Nightingale, always lower-level-first, so definitions of calling functions follow definitions of those they call. Being consistent about it can save someone reading the code a lot of time.
